/*
 * Copyright (c) 2015 HERE Global B.V. and its affiliate(s).
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
 
#include <Wire.h>

#define COMPASS_ADDRESS 0x1E
#define COMPASS_REG_MODE 0x02
#define COMPASS_REG_DATA_OUT_X 0x03

static const int latchPin = 16;
static const int clockPin = 15;
static const int dataPin = 12;
static const int oePin = 13;

// The symbols table generated by gen_symbols.py
static const byte symbols[][7] = {
  // 0x00 - question
  {0x1c, 0x22, 0x02, 0x04, 0x08, 0x00, 0x08},
  // 0x01 - up
  {0x08, 0x1c, 0x2a, 0x08, 0x08, 0x08, 0x08},
  // 0x02 - down
  {0x08, 0x08, 0x08, 0x08, 0x2a, 0x1c, 0x08},
  // 0x03 - side
  {0x00, 0x10, 0x20, 0x7f, 0x20, 0x10, 0x00},
  // 0x04 - up-diagonal
  {0x70, 0x60, 0x50, 0x08, 0x04, 0x02, 0x01},
  // 0x05 - donn-diagonal
  {0x01, 0x02, 0x04, 0x08, 0x50, 0x60, 0x70},
};

#define NUM_BASIC_SYMBOLS (sizeof(symbols) / sizeof(symbols[0]))

static byte currentSymbol = 0;

struct CompassVec {
  float x, y, z;
  CompassVec() : x(0), y(0), z(0) {}
  CompassVec(float x, float y, float z) : x(x), y(y), z(z) {}

  CompassVec minVec(const CompassVec &other) {
    return CompassVec(min(x, other.x), min(y, other.y), min(z, other.z));
  }

  CompassVec maxVec(const CompassVec &other) {
    return CompassVec(max(x, other.x), max(y, other.y), max(z, other.z));
  }

  void print() {
    Serial.print(x);
    Serial.print(" ");
    Serial.print(y);
    Serial.print(" ");
    Serial.print(z);
  }
};

class CompassClass {
private:
  CompassVec maxMeas, minMeas;

protected:
  void writeReg(byte reg, byte val) {
    Wire.beginTransmission(COMPASS_ADDRESS);
    Wire.write(reg);
    Wire.write(val);
    Wire.endTransmission();
  }

  void readRegs(byte reg, int count, byte *buf) {
    Wire.beginTransmission(COMPASS_ADDRESS);
    Wire.write(reg);
    Wire.endTransmission(false);

    Wire.requestFrom(COMPASS_ADDRESS, count);

    while (Wire.available() != count) /* wait */;

    for (int i = 0; i < count; i++)
      buf[i] = Wire.read();
  }

  int16_t makeI16(byte msb, byte lsb) {
    return static_cast<int16_t>(((uint16_t)msb << 8)  | lsb);
  }

  static float correctVal(float v, float maxVal, float minVal) {
    float range = maxVal - minVal;
    float mean = (maxVal + minVal) / 2;

    return (v - mean) / range * 2;
  }

  CompassVec applyCalibration(const CompassVec &v) const {
    CompassVec res(correctVal(v.x, maxMeas.x, minMeas.x),
                   correctVal(v.y, maxMeas.y, minMeas.y),
                   correctVal(v.z, maxMeas.z, minMeas.z));
    return res;
  }

public:
  // FIXME correction values should be saved to the EEPROM
  CompassClass() : maxMeas(258.00, 228.00, 294.00), minMeas(-244.00, -281.00, -210.00) {}

  void begin() {
    /* Set the continuous measurement mode. */
    writeReg(0, 0x70);
    writeReg(1, 0xA0);
    writeReg(2, 0);
  }

  CompassVec getMeasurements() {
    byte buf[6];

    //writeReg(2, 1);
    //delay(10);

    readRegs(COMPASS_REG_DATA_OUT_X, 6, buf);

    float x, y, z;
    x = (float)makeI16(buf[0], buf[1]);
    z = (float)makeI16(buf[2], buf[3]);
    y = (float)makeI16(buf[4], buf[5]);

    CompassVec v(x, y, z);
    return applyCalibration(v);
  }

  float getDirection() {
    CompassVec v = getMeasurements();

    float res = atan2(v.y, v.x) * 180 / M_PI;
    if (res < 0)
      return res + 360;
    return res;
  }

  void doCalibration() {
    for (;;) {
      CompassVec v = getMeasurements();
      maxMeas = maxMeas.maxVec(v);
      minMeas = minMeas.minVec(v);

      maxMeas.print();
      Serial.print("    ");
      minMeas.print();
      Serial.println("");
    }
  }
};

CompassClass Compass;

void setup() {
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(oePin, OUTPUT);
  digitalWrite(oePin, LOW);
  clearMatrix();

  Wire.begin();
  delay(100);

  Compass.begin();
}

void loop() {
  //Compass.doCalibration();
  float dir = Compass.getDirection();

  if ((dir > 337.5) || (dir <= 22.5))
    currentSymbol = 1; // north
  else if (dir <= 67.5)
    currentSymbol = 4;
  else if (dir <= 112.5)
    currentSymbol = 3;
  else if (dir <= 157.5)
    currentSymbol = 5;
  else if (dir <= 202.5)
    currentSymbol = 2;
  else if (dir <= 247.5)
    currentSymbol = 0x85;
  else if (dir <= 292.5)
    currentSymbol = 0x83;
  else
    currentSymbol = 0x84;

  showSymbol(currentSymbol);
}

/* Shows a symbol with the given encoding. High bit means mirrored symbol. */
void showSymbol(byte code)
{
  const byte *sym = symbols[0];

  boolean invert = (code & 0x80) == 0x80;
  code &= 0x7f;

  if (code < NUM_BASIC_SYMBOLS)
    sym = symbols[code];


  for (int row = 0; row < 7; row++) {
    byte columnBitsToSend = 0;
    byte rowBitsToSend = 1 << row;

    for (int col = 0; col < 7; col++) {
      if (sym[row] & (1 << col)) {
        bitWrite(columnBitsToSend, invert ? col : (6 - col), HIGH);
      }
    }

    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, MSBFIRST, rowBitsToSend);
    shiftOut(dataPin, clockPin, MSBFIRST, columnBitsToSend);
    digitalWrite(latchPin, HIGH);
  }

  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, 0);
  shiftOut(dataPin, clockPin, MSBFIRST, 0);
  digitalWrite(latchPin, HIGH);
}

void clearMatrix()
{
  showSymbol(0);
}
